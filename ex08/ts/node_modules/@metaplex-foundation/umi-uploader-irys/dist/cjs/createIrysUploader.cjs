'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var umi = require('@metaplex-foundation/umi');
var umiWeb3jsAdapters = require('@metaplex-foundation/umi-web3js-adapters');
var web3_js = require('@solana/web3.js');
var BigNumber = require('bignumber.js');
var buffer = require('buffer');
var errors = require('./errors.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);

// eslint-disable-next-line import/no-named-default

/**
 * This method is necessary to import the Irys package on both ESM and CJS modules.
 * Without this, we get a different structure on each module:
 * - CJS: { default: [Getter], WebIrys: [Getter] }
 * - ESM: { default: { default: [Getter], WebIrys: [Getter] } }
 * This method fixes this by ensure there is not double default in the imported package.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function _removeDoubleDefault(pkg) {
  if (pkg && typeof pkg === 'object' && 'default' in pkg && 'default' in pkg.default) {
    return pkg.default;
  }
  return pkg;
}
// Size of Irys transaction header.
const HEADER_SIZE = 2_000;

// Minimum file size for cost calculation.
const MINIMUM_SIZE = 80_000;
function createIrysUploader(context, options = {}) {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  let _irys = null;
  options = {
    providerUrl: context.rpc.getEndpoint(),
    ...options
  };
  const getUploadPriceFromBytes = async bytes => {
    const irys = await getIrys();
    const price = await irys.getPrice(bytes);
    return bigNumberToAmount(price.multipliedBy(options.priceMultiplier ?? 1.1));
  };
  const getUploadPrice = async files => {
    const bytes = files.reduce((sum, file) => sum + HEADER_SIZE + Math.max(MINIMUM_SIZE, file.buffer.byteLength), 0);
    return getUploadPriceFromBytes(bytes);
  };
  const upload = async files => {
    const irys = await getIrys();
    const amount = await getUploadPrice(files);
    await fund(amount);
    const promises = files.map(async file => {
      const buffer$1 = buffer.Buffer.from(file.buffer);
      const irysTx = irys.createTransaction(buffer$1, {
        tags: getGenericFileTagsWithContentType(file)
      });
      await irysTx.sign();
      const {
        status,
        data
      } = await irys.uploader.uploadTransaction(irysTx);
      if (status >= 300) {
        throw new errors.AssetUploadFailedError(status);
      }
      return `https://arweave.net/${data.id}`;
    });
    return Promise.all(promises);
  };
  const uploadJson = async json => {
    const file = umi.createGenericFileFromJson(json);
    const uris = await upload([file]);
    return uris[0];
  };
  const getBalance = async () => {
    const irys = await getIrys();
    const balance = await irys.getLoadedBalance();
    return bigNumberToAmount(balance);
  };
  const fund = async (amount, skipBalanceCheck = false) => {
    const irys = await getIrys();
    let toFund = amountToBigNumber(amount);
    if (!skipBalanceCheck) {
      const balance = await irys.getLoadedBalance();
      toFund = toFund.isGreaterThan(balance) ? toFund.minus(balance) : new BigNumber__default["default"](0);
    }
    if (toFund.isLessThanOrEqualTo(0)) {
      return;
    }
    await irys.fund(toFund);
  };
  const withdrawAll = async () => {
    // TODO(loris): Replace with "withdrawAll" when available on Irys.
    const irys = await getIrys();
    const balance = await irys.getLoadedBalance();
    const minimumBalance = new BigNumber__default["default"](5000);
    if (balance.isLessThan(minimumBalance)) {
      return;
    }
    const balanceToWithdraw = balance.minus(minimumBalance);
    await withdraw(bigNumberToAmount(balanceToWithdraw));
  };
  const withdraw = async amount => {
    const irys = await getIrys();
    try {
      await irys.withdrawBalance(amountToBigNumber(amount));
    } catch (e) {
      throw new errors.IrysWithdrawError(e instanceof Error ? e.message : e.toString());
    }
  };
  const getIrys = async () => {
    const oldPayer = _irys?.getSigner().publicKey;
    const newPayer = options.payer ?? context.payer;
    if (oldPayer && umi.publicKey(new Uint8Array(oldPayer)) !== newPayer.publicKey) {
      _irys = null;
    }
    if (!_irys) {
      _irys = await initIrys();
    }
    return _irys;
  };
  const initIrys = async () => {
    const currency = 'solana';
    const defaultAddress = context.rpc.getCluster() === 'devnet' ? 'https://devnet.irys.xyz' : 'https://node1.irys.xyz';
    const address = options?.address ?? defaultAddress;
    const irysOptions = {
      timeout: options.timeout,
      providerUrl: options.providerUrl
    };
    const payer = options.payer ?? context.payer;

    // If in node use node irys, else use web irys.
    const isNode =
    // eslint-disable-next-line no-prototype-builtins
    typeof window === 'undefined' || window.process?.hasOwnProperty('type');
    let irys;
    if (isNode && umi.isKeypairSigner(payer)) irys = await initNodeIrys(address, currency, payer, irysOptions);else {
      irys = await initWebIrys(address, currency, payer, irysOptions);
    }
    try {
      // Check for valid irys node.
      await irys.utils.getBundlerAddress(currency);
    } catch (error) {
      throw new errors.FailedToConnectToIrysAddressError(address, error);
    }
    return irys;
  };
  const initNodeIrys = async (address, currency, keypair, options) => {
    const bPackage = _removeDoubleDefault(await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@irys/sdk')); }));
    // eslint-disable-next-line new-cap
    return new bPackage.default({
      url: address,
      token: currency,
      key: keypair.secretKey,
      config: options
    });
  };
  const initWebIrys = async (address, currency, payer, options) => {
    const wallet = {
      publicKey: umiWeb3jsAdapters.toWeb3JsPublicKey(payer.publicKey),
      signMessage: message => payer.signMessage(message),
      signTransaction: async web3JsTransaction => umiWeb3jsAdapters.toWeb3JsLegacyTransaction(await payer.signTransaction(umiWeb3jsAdapters.fromWeb3JsLegacyTransaction(web3JsTransaction))),
      signAllTransactions: async web3JsTransactions => {
        const transactions = web3JsTransactions.map(umiWeb3jsAdapters.fromWeb3JsLegacyTransaction);
        const signedTransactions = await payer.signAllTransactions(transactions);
        return signedTransactions.map(umiWeb3jsAdapters.toWeb3JsLegacyTransaction);
      },
      sendTransaction: async (web3JsTransaction, connection, options = {}) => {
        const {
          signers: web3JsSigners = [],
          ...sendOptions
        } = options;
        const signers = web3JsSigners.map(web3JsSigner => umi.createSignerFromKeypair(context, umiWeb3jsAdapters.fromWeb3JsKeypair(web3_js.Keypair.fromSecretKey(web3JsSigner.secretKey))));
        let transaction = umiWeb3jsAdapters.fromWeb3JsLegacyTransaction(web3JsTransaction);
        transaction = await umi.signTransaction(transaction, [payer, ...signers]);
        const signature = await context.rpc.sendTransaction(transaction, {
          ...sendOptions,
          preflightCommitment: sendOptions.preflightCommitment
        });
        return umi.base58.deserialize(signature)[0];
      }
    };
    const bPackage = _removeDoubleDefault(await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@irys/sdk')); }));
    const irys = new bPackage.WebIrys({
      url: address,
      token: currency,
      wallet: {
        provider: wallet
      },
      config: options
    });
    try {
      // Try to initiate irys.
      await irys.ready();
    } catch (error) {
      throw new errors.FailedToInitializeIrysError(error);
    }
    return irys;
  };
  return {
    getUploadPriceFromBytes,
    getUploadPrice,
    upload,
    uploadJson,
    getBalance,
    fund,
    withdrawAll,
    withdraw,
    irys: getIrys
  };
}
const isIrysUploader = uploader => 'irys' in uploader && 'getBalance' in uploader && 'fund' in uploader && 'withdrawAll' in uploader;
const bigNumberToAmount = bigNumber => umi.lamports(bigNumber.decimalPlaces(0).toString());
const amountToBigNumber = amount => new BigNumber__default["default"](amount.basisPoints.toString());
const getGenericFileTagsWithContentType = file => {
  if (!file.contentType) {
    return file.tags;
  }
  return [{
    name: 'Content-Type',
    value: file.contentType
  }, ...file.tags];
};

exports.createIrysUploader = createIrysUploader;
exports.isIrysUploader = isIrysUploader;
//# sourceMappingURL=createIrysUploader.cjs.map
