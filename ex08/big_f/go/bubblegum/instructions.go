// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package bubblegum

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

var ProgramID ag_solanago.PublicKey

func SetProgramID(pubkey ag_solanago.PublicKey) {
	ProgramID = pubkey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

const ProgramName = "Bubblegum"

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var (
	Instruction_Burn = ag_binary.TypeID([8]byte{116, 110, 29, 56, 107, 219, 42, 93})

	Instruction_CancelRedeem = ag_binary.TypeID([8]byte{111, 76, 232, 50, 39, 175, 48, 242})

	Instruction_CreateTree = ag_binary.TypeID([8]byte{165, 83, 136, 142, 89, 202, 47, 220})

	Instruction_DecompressV1 = ag_binary.TypeID([8]byte{54, 85, 76, 70, 228, 250, 164, 81})

	Instruction_Delegate = ag_binary.TypeID([8]byte{90, 147, 75, 178, 85, 88, 4, 137})

	Instruction_MintToCollectionV1 = ag_binary.TypeID([8]byte{153, 18, 178, 47, 197, 158, 86, 15})

	Instruction_MintV1 = ag_binary.TypeID([8]byte{145, 98, 192, 118, 184, 147, 118, 104})

	Instruction_Redeem = ag_binary.TypeID([8]byte{184, 12, 86, 149, 70, 196, 97, 225})

	Instruction_SetAndVerifyCollection = ag_binary.TypeID([8]byte{235, 242, 121, 216, 158, 234, 180, 234})

	Instruction_SetDecompressibleState = ag_binary.TypeID([8]byte{82, 104, 152, 6, 149, 111, 100, 13})

	Instruction_SetTreeDelegate = ag_binary.TypeID([8]byte{253, 118, 66, 37, 190, 49, 154, 102})

	Instruction_Transfer = ag_binary.TypeID([8]byte{163, 52, 200, 231, 140, 3, 69, 186})

	Instruction_UnverifyCollection = ag_binary.TypeID([8]byte{250, 251, 42, 106, 41, 137, 186, 168})

	Instruction_UnverifyCreator = ag_binary.TypeID([8]byte{107, 178, 57, 39, 105, 115, 112, 152})

	Instruction_VerifyCollection = ag_binary.TypeID([8]byte{56, 113, 101, 253, 79, 55, 122, 169})

	Instruction_VerifyCreator = ag_binary.TypeID([8]byte{52, 17, 96, 132, 71, 4, 85, 194})

	Instruction_UpdateMetadata = ag_binary.TypeID([8]byte{170, 182, 43, 239, 97, 78, 225, 186})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_Burn:
		return "Burn"
	case Instruction_CancelRedeem:
		return "CancelRedeem"
	case Instruction_CreateTree:
		return "CreateTree"
	case Instruction_DecompressV1:
		return "DecompressV1"
	case Instruction_Delegate:
		return "Delegate"
	case Instruction_MintToCollectionV1:
		return "MintToCollectionV1"
	case Instruction_MintV1:
		return "MintV1"
	case Instruction_Redeem:
		return "Redeem"
	case Instruction_SetAndVerifyCollection:
		return "SetAndVerifyCollection"
	case Instruction_SetDecompressibleState:
		return "SetDecompressibleState"
	case Instruction_SetTreeDelegate:
		return "SetTreeDelegate"
	case Instruction_Transfer:
		return "Transfer"
	case Instruction_UnverifyCollection:
		return "UnverifyCollection"
	case Instruction_UnverifyCreator:
		return "UnverifyCreator"
	case Instruction_VerifyCollection:
		return "VerifyCollection"
	case Instruction_VerifyCreator:
		return "VerifyCreator"
	case Instruction_UpdateMetadata:
		return "UpdateMetadata"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			"burn", (*Burn)(nil),
		},
		{
			"cancel_redeem", (*CancelRedeem)(nil),
		},
		{
			"create_tree", (*CreateTree)(nil),
		},
		{
			"decompress_v1", (*DecompressV1)(nil),
		},
		{
			"delegate", (*Delegate)(nil),
		},
		{
			"mint_to_collection_v1", (*MintToCollectionV1)(nil),
		},
		{
			"mint_v1", (*MintV1)(nil),
		},
		{
			"redeem", (*Redeem)(nil),
		},
		{
			"set_and_verify_collection", (*SetAndVerifyCollection)(nil),
		},
		{
			"set_decompressible_state", (*SetDecompressibleState)(nil),
		},
		{
			"set_tree_delegate", (*SetTreeDelegate)(nil),
		},
		{
			"transfer", (*Transfer)(nil),
		},
		{
			"unverify_collection", (*UnverifyCollection)(nil),
		},
		{
			"unverify_creator", (*UnverifyCreator)(nil),
		},
		{
			"verify_collection", (*VerifyCollection)(nil),
		},
		{
			"verify_creator", (*VerifyCreator)(nil),
		},
		{
			"update_metadata", (*UpdateMetadata)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := DecodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func DecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
